<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AI í•œì ì„ ìƒë‹˜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background:#f7f7f7; }
    .chat-box { max-height: 60vh; overflow-y: auto; }
    .bubble { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body class="p-4">

<button onclick="toggleAI()"
  class="fixed bottom-4 right-4 bg-black text-white rounded-full w-12 h-12 flex items-center justify-center shadow-lg">
  ğŸ¤–
</button>

<div id="ai-panel"
  class="hidden fixed bottom-20 right-4 w-[390px] bg-white rounded-xl shadow-xl flex flex-col">

  <div class="bg-black text-white px-4 py-2 rounded-t-xl flex justify-between items-center">
    <span id="uiTitle">AI í•œì ì„ ìƒë‹˜</span>
    <button onclick="toggleAI()">âœ–</button>
  </div>

  <!-- æ§åˆ¶åŒº -->
  <div class="px-3 pt-3 pb-2 border-b text-xs space-y-2">
    <div class="flex items-center gap-2">
      <input id="ttsToggle" type="checkbox" checked class="accent-orange-500" />
      <label id="uiTtsLabel">ì½ì–´ì£¼ê¸°(TTS)</label>

      <button id="uiTestVoiceBtn" type="button"
        class="ml-auto px-2 py-1 rounded bg-slate-200">
        ğŸ”Š í…ŒìŠ¤íŠ¸
      </button>
    </div>

    <div class="flex items-center gap-2">
      <span id="uiVoiceLabel" class="w-[72px] text-gray-600">ìŒìƒ‰</span>
      <select id="voiceSelect" class="flex-1 border rounded px-2 py-1 text-xs"></select>
    </div>

    <div class="flex items-center gap-2">
      <span id="uiExplainLabel" class="w-[72px] text-gray-600">ì„¤ëª… ì–¸ì–´</span>
      <select id="explainLang" class="flex-1 border rounded px-2 py-1 text-xs">
        <option value="ko" selected>í•œêµ­ì–´</option>
        <option value="en">English</option>
        <option value="ja">æ—¥æœ¬èª</option>
        <option value="zh">ä¸­æ–‡</option>
      </select>
    </div>

    <!-- âœ… æœ—è¯»èŒƒå›´ï¼ˆä½ è¦çš„ï¼šåªè¯»ä¸­æ–‡ / ä¸­æ–‡+è§£é‡Š / å…¨éƒ¨ï¼‰ -->
    <div class="flex items-center gap-2">
      <span id="uiReadScopeLabel" class="w-[72px] text-gray-600">ì½ê¸° ë²”ìœ„</span>
      <select id="readScope" class="flex-1 border rounded px-2 py-1 text-xs">
        <option value="zhOnly">ä¸­æ–‡ë§Œ</option>
        <option value="zhPlus">ä¸­æ–‡+ì„¤ëª…</option>
        <option value="all" selected>ì „ì²´</option>
      </select>
    </div>

    <!-- âœ… æ¨¡å¼ï¼šå„¿ç«¥/è€ƒè¯• -->
    <div class="flex items-center gap-2">
      <span id="uiModeLabel" class="w-[72px] text-gray-600">ëª¨ë“œ</span>
      <select id="speakMode" class="flex-1 border rounded px-2 py-1 text-xs">
        <option value="kids" selected>Kids</option>
        <option value="exam">Exam</option>
      </select>
    </div>
  </div>

  <div id="chat" class="chat-box p-3 space-y-2 text-sm"></div>

  <div class="p-3 border-t flex gap-2">
    <input id="input" class="flex-1 border rounded px-2 py-2"
      placeholder="ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”â€¦"
      onkeydown="if(event.key==='Enter') send();" />
    <button id="uiSendBtn" onclick="send()" class="bg-orange-500 text-white px-4 py-2 rounded">
      ë³´ë‚´ê¸°
    </button>
  </div>

  <div id="uiKeyMode" class="text-xs text-center text-gray-500 pb-2">
    ğŸ” Key ë³´í˜¸ ëª¨ë“œ: Vercel API
  </div>
</div>

<script>
/* =========================
   0) API
========================= */
const API_URL = "https://hanjiapass.vercel.app/api/gemini";

/* =========================
   1) UI å¤šè¯­è¨€æ–‡æ¡ˆ
========================= */
const UI_TEXT = {
  ko: {
    title: "AI í•œì ì„ ìƒë‹˜",
    inputPlaceholder: "ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”â€¦",
    send: "ë³´ë‚´ê¸°",
    explainLang: "ì„¤ëª… ì–¸ì–´",
    tts: "ì½ì–´ì£¼ê¸°(TTS)",
    voice: "ìŒìƒ‰",
    testVoice: "ğŸ”Š í…ŒìŠ¤íŠ¸",
    keyMode: "ğŸ” Key ë³´í˜¸ ëª¨ë“œ: Vercel API",
    thinking: "ì ê¹ë§Œìš” ğŸ™‚",
    welcome: "ì•ˆë…•í•˜ì„¸ìš” ğŸ™‚\nì¤‘êµ­ì–´ ì§ˆë¬¸, ë°”ë¡œ ë¬¼ì–´ë³´ì„¸ìš”!",
    readScope: "ì½ê¸° ë²”ìœ„",
    mode: "ëª¨ë“œ",
    follow: "ğŸ¤ ë”°ë¼ì½ê¸°"
  },
  en: {
    title: "AI Chinese Teacher",
    inputPlaceholder: "Ask your questionâ€¦",
    send: "Send",
    explainLang: "Explanation language",
    tts: "Read aloud (TTS)",
    voice: "Voice",
    testVoice: "ğŸ”Š Test",
    keyMode: "ğŸ” Key protection: Vercel API",
    thinking: "One sec ğŸ™‚",
    welcome: "Hi ğŸ™‚\nAsk me anything about Chinese!",
    readScope: "Read scope",
    mode: "Mode",
    follow: "ğŸ¤ Shadow"
  },
  ja: {
    title: "AI ä¸­å›½èªå…ˆç”Ÿ",
    inputPlaceholder: "è³ªå•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„â€¦",
    send: "é€ä¿¡",
    explainLang: "èª¬æ˜è¨€èª",
    tts: "èª­ã¿ä¸Šã’(TTS)",
    voice: "éŸ³å£°",
    testVoice: "ğŸ”Š ãƒ†ã‚¹ãƒˆ",
    keyMode: "ğŸ” ã‚­ãƒ¼ä¿è­·: Vercel API",
    thinking: "ã¡ã‚‡ã£ã¨å¾…ã£ã¦ã­ ğŸ™‚",
    welcome: "ã“ã‚“ã«ã¡ã¯ ğŸ™‚\nä¸­å›½èªã€æ°—è»½ã«èã„ã¦ãã ã•ã„ã€‚",
    readScope: "èª­ã¿ç¯„å›²",
    mode: "ãƒ¢ãƒ¼ãƒ‰",
    follow: "ğŸ¤ ã¤ã„ã¦èª­ã‚€"
  },
  zh: {
    title: "AI æ±‰å­—è€å¸ˆ",
    inputPlaceholder: "è¯·è¾“å…¥ä½ çš„é—®é¢˜â€¦",
    send: "å‘é€",
    explainLang: "è¯´æ˜è¯­è¨€",
    tts: "æœ—è¯»(TTS)",
    voice: "éŸ³è‰²",
    testVoice: "ğŸ”Š æµ‹è¯•",
    keyMode: "ğŸ” å¯†é’¥ä¿æŠ¤ï¼šVercel API",
    thinking: "ç­‰ä¸€ä¸‹ğŸ™‚",
    welcome: "ä½ å¥½ ğŸ™‚\næœ‰ä¸­æ–‡é—®é¢˜ï¼Œç›´æ¥é—®æˆ‘å§ã€‚",
    readScope: "æœ—è¯»èŒƒå›´",
    mode: "æ¨¡å¼",
    follow: "ğŸ¤ è·Ÿè¯»"
  }
};

/* =========================
   2) DOM
========================= */
const panel = document.getElementById("ai-panel");
const chat  = document.getElementById("chat");
const input = document.getElementById("input");
const explainLang = document.getElementById("explainLang");
const ttsToggle = document.getElementById("ttsToggle");
const voiceSelect = document.getElementById("voiceSelect");
const readScope = document.getElementById("readScope");
const speakMode = document.getElementById("speakMode");

const uiTitle = document.getElementById("uiTitle");
const uiTtsLabel = document.getElementById("uiTtsLabel");
const uiVoiceLabel = document.getElementById("uiVoiceLabel");
const uiExplainLabel = document.getElementById("uiExplainLabel");
const uiSendBtn = document.getElementById("uiSendBtn");
const uiKeyMode = document.getElementById("uiKeyMode");
const uiTestVoiceBtn = document.getElementById("uiTestVoiceBtn");
const uiReadScopeLabel = document.getElementById("uiReadScopeLabel");
const uiModeLabel = document.getElementById("uiModeLabel");

/* =========================
   3) å®‰å…¨ï¼šæŠ¥é”™æ˜¾ç¤º
========================= */
function showError(msg) {
  createMsgBubble("ì˜¤ë¥˜: " + msg, "ai");
}
window.addEventListener("error", (e) => {
  showError(e?.message || "Unknown error");
});

/* =========================
   4) UI åŸºç¡€
========================= */
function toggleAI() {
  panel.classList.toggle("hidden");
}

function cleanForDisplay(text) {
  return String(text)
    .replace(/```[\s\S]*?```/g, "")
    .replace(/\*\*(.*?)\*\*/g, "$1")
    .replace(/#+\s*/g, "")
    .replace(/-{3,}/g, "")
    .trim();
}
/* =========================
   âœ… ä¾‹å¥å¯ç‚¹å‡»æœ—è¯»ï¼šæŠŠâ€œä¾‹å¥1/2ï¼š...â€è½¬æˆæŒ‰é’®
========================= */

// ç”¨æ¥æŠŠä¾‹å¥è¡Œè§£æå‡ºæ¥
function parseExampleLines(text) {
  const raw = String(text || "");
  const lines = raw.split(/\n+/).map(s => s.trim()).filter(Boolean);
  const examples = [];

  // æ”¯æŒï¼šä¾‹å¥1ï¼šxxx | pinyin | explain
  // ä¹Ÿæ”¯æŒï¼šExample 1: ...ï¼ˆè‹±æ–‡ç•Œé¢æ—¶æœ‰æ¦‚ç‡ï¼‰
  const re = /^(?:ä¾‹å¥|ì˜ˆë¬¸|Example)\s*([0-9]+)\s*[:ï¼š]\s*(.+)$/i;

  for (const line of lines) {
    const m = line.match(re);
    if (!m) continue;
    const idx = m[1];
    const rest = m[2];

    // rest: ä¸­æ–‡ | æ‹¼éŸ³ | è§£é‡Š
    const parts = rest.split("|").map(s => s.trim());
    const zh = parts[0] || "";
    const py = parts[1] || "";
    const exp = parts.slice(2).join(" | ") || "";

    examples.push({ idx, zh, py, exp, fullLine: line });
  }
  return examples;
}

// æŠŠä¾‹å¥æŒ‰é’®æ’åˆ°æ°”æ³¡ä¸‹é¢
function appendExampleButtons(wrapEl, answerText, uiLang) {
  const examples = parseExampleLines(answerText);
  if (!examples.length) return;

  const t = UI_TEXT[uiLang] || UI_TEXT.ko;

  const box = document.createElement("div");
  box.className = "mt-2 flex flex-wrap gap-2";

  examples.forEach(ex => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "px-2 py-1 rounded bg-white border text-xs hover:bg-slate-50";
    btn.textContent = `ğŸ”Š ${t.follow} ${ex.idx}`; // å¤ç”¨ follow æ–‡æ¡ˆæ›´çœäº‹

    btn.addEventListener("click", async () => {
      // ç‚¹å“ªå¥è¯»å“ªå¥ï¼šä¸­æ–‡æ™®é€šè¯ï¼Œå…¶å®ƒæŒ‰ç•Œé¢è¯­è¨€è¯»
      const lineToRead = `${ex.zh} ${ex.py ? (" " + ex.py) : ""}`; 
      // å¦‚æœä½ ä¹Ÿæƒ³æŠŠè§£é‡Šä¸€èµ·è¯»ï¼Œå°±ç”¨ä¸‹é¢è¿™è¡Œæ›¿æ¢ï¼š
      // const lineToRead = `${ex.zh} | ${ex.py} | ${ex.exp}`;

      await speakSmart(lineToRead, uiLang);
    });

    box.appendChild(btn);
  });

  wrapEl.appendChild(box);
  chat.scrollTop = chat.scrollHeight;
}
  
function createMsgBubble(initialText, who) {
  const wrap = document.createElement("div");
  wrap.className = who === "user" ? "text-right" : "text-left";

  const bubbleClass = who === "user" ? "bg-orange-500 text-white" : "bg-gray-200";
  wrap.innerHTML = `
    <span class="inline-block px-3 py-2 rounded-lg ${bubbleClass}">
      <div class="bubble"></div>
    </span>
  `;
  const bubbleDiv = wrap.querySelector(".bubble");
  bubbleDiv.textContent = cleanForDisplay(initialText);

  chat.appendChild(wrap);
  chat.scrollTop = chat.scrollHeight;
  return { wrap, bubbleDiv };
}

/* =========================
   5) UI è·Ÿéšè¯­è¨€åˆ‡æ¢
========================= */
function applyUIText(lang) {
  const t = UI_TEXT[lang] || UI_TEXT.ko;

  uiTitle.innerText = t.title;
  input.placeholder = t.inputPlaceholder;
  uiSendBtn.innerText = t.send;

  uiTtsLabel.innerText = t.tts;
  uiVoiceLabel.innerText = t.voice;
  uiExplainLabel.innerText = t.explainLang;
  uiTestVoiceBtn.innerText = t.testVoice;
  uiKeyMode.innerText = t.keyMode;
  uiReadScopeLabel.innerText = t.readScope;
  uiModeLabel.innerText = t.mode;

  // æ¬¢è¿è¯­
  chat.innerHTML = "";
  createMsgBubble(t.welcome, "ai");
}

/* =========================
   6) TTSï¼šSmartï¼ˆä¸­æ–‡æ™®é€šè¯ï¼Œå…¶å®ƒè·Ÿéšé€‰æ‹©è¯­è¨€ï¼‰
   + è‡ªç„¶åœé¡¿ï¼ˆçœŸäººæ„Ÿï¼‰
========================= */
let voices = [];

function loadVoices() {
  voices = window.speechSynthesis ? (window.speechSynthesis.getVoices() || []) : [];
  voiceSelect.innerHTML = "";

  if (!voices.length) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "(No voices yet)";
    voiceSelect.appendChild(opt);
    return;
  }

  voices.forEach((v, idx) => {
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = `${v.name} - ${v.lang}`;
    voiceSelect.appendChild(opt);
  });

  voiceSelect.value = "0";
}

if (window.speechSynthesis) {
  window.speechSynthesis.onvoiceschanged = loadVoices;
  loadVoices();
}

// é€‰â€œæœ€åƒç›®æ ‡è¯­è¨€â€çš„ voiceï¼ˆæ‰¾ä¸åˆ°å°±ç”¨ä¸‹æ‹‰é€‰çš„ï¼‰
function pickVoiceByLang(targetLang) {
  if (!voices.length) return null;

  const prefix = {
    zh: ["zh", "cmn"],
    en: ["en"],
    ko: ["ko"],
    ja: ["ja"]
  }[targetLang] || [targetLang];

  const v = voices.find(v => prefix.some(p => (v.lang || "").toLowerCase().startsWith(p)));
  if (v) return v;

  const idx = parseInt(voiceSelect.value, 10);
  if (!Number.isNaN(idx) && voices[idx]) return voices[idx];

  return voices[0] || null;
}

// æ¸…ç†ï¼šå»æ‰ markdown/è£…é¥°ç¬¦å·ï¼Œä¿ç•™è¯­è¨€æ–‡å­—
function cleanForSpeak(text) {
  return String(text)
    .replace(/```[\s\S]*?```/g, " ")
    .replace(/\*\*(.*?)\*\*/g, "$1")
    .replace(/#+\s*/g, "")
    .replace(/-{3,}/g, " ")
    .replace(/[â€¢â—â—¦â–¶â–·â– â–¡â—†â—‡â€»â˜…â˜†]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

// åªä¿ç•™ä¸»è¦æ–‡å­—ï¼Œå‡å°‘è¯»æ ‡ç‚¹ï¼ˆä½†ä¿ç•™å¥å­åœé¡¿ç”¨çš„åˆ†éš”ç¬¦ï¼‰
function keepLettersForLang(text, lang) {
  const t = String(text);

  if (lang === "en") {
    return t.replace(/[^A-Za-z0-9\s'.,!?-]/g, " ").replace(/\s+/g, " ").trim();
  }
  if (lang === "ko") {
    return t.replace(/[^ê°€-í£0-9\s.,!?-]/g, " ").replace(/\s+/g, " ").trim();
  }
  if (lang === "ja") {
    return t.replace(/[^ã-ã‚Ÿã‚ -ãƒ¿ä¸€-é¾¯0-9\s.,!?-]/g, " ").replace(/\s+/g, " ").trim();
  }
  if (lang === "zh") {
    return t.replace(/[^\u4e00-\u9fff0-9\sï¼Œã€‚ï¼ï¼Ÿã€]/g, " ").replace(/\s+/g, " ").trim();
  }
  return t.replace(/\s+/g, " ").trim();
}

// ä¸­æ–‡/éä¸­æ–‡åˆ‡å—
function splitByChineseRuns(text) {
  const s = cleanForSpeak(text);
  if (!s) return [];

  const parts = [];
  const re = /([\u4e00-\u9fff]+)|([^\u4e00-\u9fff]+)/g;
  let m;
  while ((m = re.exec(s)) !== null) {
    if (m[1]) parts.push({ type: "zh", text: m[1] });
    else if (m[2]) parts.push({ type: "other", text: m[2] });
  }
  return parts;
}

// âœ… è‡ªç„¶åœé¡¿ï¼šæŠŠæ–‡æœ¬æŒ‰å¥å·/é—®å·/æ„Ÿå¹å·åˆ‡å¥
function splitSentences(text) {
  const s = String(text).trim();
  if (!s) return [];
  // ä¸­è‹±æ—¥éŸ©å¸¸è§å¥æœ«ç¬¦å·
  const re = /[^ã€‚ï¼ï¼Ÿ!?]+[ã€‚ï¼ï¼Ÿ!?]?/g;
  return s.match(re)?.map(x => x.trim()).filter(Boolean) || [s];
}

function getSpeakParams() {
  const mode = speakMode.value; // kids / exam
  if (mode === "exam") {
    return { rate: 1.05, pitch: 1.0, pauseShort: 120, pauseLong: 220 };
  }
  // kids
  return { rate: 0.98, pitch: 1.07, pauseShort: 180, pauseLong: 320 };
}

// âœ… æœ—è¯»èŒƒå›´ï¼šåªè¯»ä¸­æ–‡ / ä¸­æ–‡+è§£é‡Š / å…¨éƒ¨
function filterByReadScope(fullText, uiLang, scope) {
  const text = cleanForSpeak(fullText);

  if (scope === "zhOnly") {
    // åªä¿ç•™ä¸­æ–‡
    const onlyZh = (text.match(/[\u4e00-\u9fff]+/g) || []).join(" ");
    return { mode: "zhOnly", zhText: onlyZh, otherText: "" };
  }

  if (scope === "zhPlus") {
    // ä¸­æ–‡ + éä¸­æ–‡ï¼ˆä½†éä¸­æ–‡åªè¯» uiLang çš„ä¸»è¦æ–‡å­—ï¼‰
    return { mode: "zhPlus", zhText: text, otherText: text };
  }

  // all
  return { mode: "all", zhText: text, otherText: text };
}

// âœ… Smart Speakï¼ˆæ’é˜Ÿæœ—è¯» + å¥é—´åœé¡¿ï¼‰
let speakingJobId = 0;

async function speakSmart(fullText, uiLang) {
  if (!ttsToggle.checked) return;
  if (!window.speechSynthesis) return;

  const jobId = ++speakingJobId;
  const scope = readScope.value;
  const params = getSpeakParams();

  // è¿‡æ»¤èŒƒå›´
  const filtered = filterByReadScope(fullText, uiLang, scope);

  // åªè¯»ä¸­æ–‡
  if (filtered.mode === "zhOnly") {
    const t = keepLettersForLang(filtered.zhText, "zh");
    if (!t) return;
    await speakQueueByLang(t, "zh", params, jobId);
    return;
  }

  // ä¸­æ–‡+è§£é‡Š / å…¨éƒ¨ï¼šæŒ‰â€œä¸­æ–‡å—/éä¸­æ–‡å—â€åˆ†æ®µï¼Œå†åˆ‡å¥æœ—è¯»
  const chunks = splitByChineseRuns(filtered.otherText);
  if (!chunks.length) return;

  window.speechSynthesis.cancel();

  for (const c of chunks) {
    if (jobId !== speakingJobId) return;

    if (c.type === "zh") {
      const t = keepLettersForLang(c.text, "zh");
      if (!t) continue;
      await speakQueueByLang(t, "zh", params, jobId);
    } else {
      // éä¸­æ–‡ï¼šç”¨ uiLang
      const t = keepLettersForLang(c.text, uiLang);
      if (!t) continue;

      // zhPlus æ¨¡å¼ï¼šæ›´â€œçŸ­ä¸€ç‚¹â€ï¼Œé¿å…è§£é‡Šè¯»å¤ªé•¿ï¼ˆä»ç„¶ä¼šè¯»ï¼Œä½†æ›´å…‹åˆ¶ï¼‰
      if (filtered.mode === "zhPlus") {
        const shortened = t.length > 260 ? (t.slice(0, 260) + " ...") : t;
        await speakQueueByLang(shortened, uiLang, params, jobId);
      } else {
        await speakQueueByLang(t, uiLang, params, jobId);
      }
    }
  }
}

// æŒ‰è¯­è¨€æœ—è¯» + å¥é—´è‡ªç„¶åœé¡¿
function speakQueueByLang(text, langKey, params, jobId) {
  return new Promise((resolve) => {
    const sentences = splitSentences(text);
    if (!sentences.length) return resolve();

    let idx = 0;

    const speakNext = () => {
      if (jobId !== speakingJobId) return resolve();
      if (idx >= sentences.length) return resolve();

      const s = sentences[idx++];
      const u = new SpeechSynthesisUtterance(s);

      const voice = pickVoiceByLang(langKey);
      if (voice) {
        u.voice = voice;
        u.lang = voice.lang || (langKey === "zh" ? "zh-CN" : langKey);
      } else {
        u.lang = (langKey === "zh" ? "zh-CN" : langKey);
      }

      u.rate = params.rate;
      u.pitch = params.pitch;

      // å¥æœ«åœé¡¿æ›´é•¿
      const endsWithStrong = /[ã€‚ï¼ï¼Ÿ!?]$/.test(s);
      const pause = endsWithStrong ? params.pauseLong : params.pauseShort;

      u.onend = () => setTimeout(speakNext, pause);
      u.onerror = () => resolve();

      window.speechSynthesis.speak(u);
    };

    speakNext();
  });
}

// âœ… æµ‹è¯•æŒ‰é’®ï¼šæ ¹æ®å½“å‰è¯­è¨€è¯» demoï¼ˆä¿ç•™ä½ å–œæ¬¢çš„åŠŸèƒ½ï¼‰
uiTestVoiceBtn.addEventListener("click", async () => {
  const lang = explainLang.value;
  const demo = {
    ko: "ì•ˆë…•í•˜ì„¸ìš”. ä½ å¥½. ì˜¤ëŠ˜ë„ ê°™ì´ ê³µë¶€í•´ìš”!",
    en: "Hello. ä½ å¥½. Let's learn together!",
    ja: "ã“ã‚“ã«ã¡ã¯ã€‚ä½ å¥½ã€‚ã„ã£ã—ã‚‡ã«å‹‰å¼·ã—ã‚ˆã†ã€‚",
    zh: "ä½ å¥½ã€‚Hello. æˆ‘ä»¬ä¸€èµ·å­¦ä¹ å§ã€‚"
  }[lang] || "Hello. ä½ å¥½.";

  await speakSmart(demo, lang);
});

/* =========================
   7) æ‰“å­—æœºæ•ˆæœï¼ˆå®Œæˆåå›è°ƒï¼‰
========================= */
let typingTimer = null;
function stopTyping() {
  if (typingTimer) {
    clearInterval(typingTimer);
    typingTimer = null;
  }
}

function typewriterRender(bubbleDiv, fullText, speed = 14, onDone) {
  stopTyping();
  const cleaned = cleanForDisplay(fullText);

  bubbleDiv.textContent = "";
  let i = 0;

  typingTimer = setInterval(() => {
    i += 1;
    bubbleDiv.textContent = cleaned.slice(0, i);
    chat.scrollTop = chat.scrollHeight;

    if (i >= cleaned.length) {
      stopTyping();
      if (typeof onDone === "function") onDone(cleaned);
    }
  }, speed);
}

/* =========================
   8) è·Ÿè¯»ï¼ˆä¿å­˜æœ€è¿‘ä¸€æ¬¡ AI å›å¤ï¼‰
========================= */
let lastAnswerText = "";
function addFollowButton(lang) {
  const t = UI_TEXT[lang] || UI_TEXT.ko;

  const wrap = document.createElement("div");
  wrap.className = "text-left";

  wrap.innerHTML = `
    <button class="mt-1 px-3 py-1 rounded bg-slate-200 text-xs">
      ${t.follow}
    </button>
  `;
  const btn = wrap.querySelector("button");
  btn.addEventListener("click", async () => {
    if (!lastAnswerText) return;
    await speakSmart(lastAnswerText, explainLang.value);
  });

  chat.appendChild(wrap);
  chat.scrollTop = chat.scrollHeight;
}

/* =========================
   9) å‘é€
========================= */
async function send() {
  const msg = input.value.trim();
  if (!msg) return;

  stopTyping();
  window.speechSynthesis && window.speechSynthesis.cancel();

  createMsgBubble(msg, "user");
  input.value = "";

  const lang = explainLang.value;
  const t = UI_TEXT[lang] || UI_TEXT.ko;

  const { bubbleDiv } = createMsgBubble(t.thinking, "ai");

  try {
    const res = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt: msg, explainLang: lang })
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data?.error || ("HTTP " + res.status));

    const answer = data.text || "(ì‘ë‹µ ì—†ìŒ)";
    lastAnswerText = answer;

    // âœ… æ‰“å­—æœºï¼šæ‰“å®Œå†æœ—è¯»ï¼ˆæ›´åƒçœŸäººï¼‰
    typewriterRender(bubbleDiv, answer, 14, async () => {
  await speakSmart(answer, lang);
  addFollowButton(lang);

  // âœ… æ–°å¢ï¼šæ¯ä¸ªä¾‹å¥ç”Ÿæˆå¯ç‚¹å‡»æœ—è¯»æŒ‰é’®
  appendExampleButtons(bubbleDiv.closest("div"), answer, lang);
});

  } catch (e) {
    bubbleDiv.textContent = "ì˜¤ë¥˜: " + (e.message || "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");
  }
}

/* =========================
   10) åˆå§‹åŒ– & åˆ‡æ¢è¯­è¨€
========================= */
applyUIText(explainLang.value);

explainLang.addEventListener("change", () => {
  stopTyping();
  applyUIText(explainLang.value);
});
</script>

</body>
</html>
